// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: history.sql

package database

import (
	"context"
	"database/sql"
)

const createHistoryEntry = `-- name: CreateHistoryEntry :one
INSERT INTO history (
    collection_id, collection_name, endpoint_name,
    method, url, status_code, duration, response_size,
    request_headers, query_params, request_body,
    response_body, response_headers, executed_at
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, collection_id, collection_name, endpoint_name, method, url, status_code, duration, response_size, request_headers, query_params, request_body, response_body, response_headers, executed_at
`

type CreateHistoryEntryParams struct {
	CollectionID    sql.NullInt64  `db:"collection_id" json:"collection_id"`
	CollectionName  sql.NullString `db:"collection_name" json:"collection_name"`
	EndpointName    sql.NullString `db:"endpoint_name" json:"endpoint_name"`
	Method          string         `db:"method" json:"method"`
	Url             string         `db:"url" json:"url"`
	StatusCode      int64          `db:"status_code" json:"status_code"`
	Duration        int64          `db:"duration" json:"duration"`
	ResponseSize    sql.NullInt64  `db:"response_size" json:"response_size"`
	RequestHeaders  sql.NullString `db:"request_headers" json:"request_headers"`
	QueryParams     sql.NullString `db:"query_params" json:"query_params"`
	RequestBody     sql.NullString `db:"request_body" json:"request_body"`
	ResponseBody    sql.NullString `db:"response_body" json:"response_body"`
	ResponseHeaders sql.NullString `db:"response_headers" json:"response_headers"`
	ExecutedAt      string         `db:"executed_at" json:"executed_at"`
}

func (q *Queries) CreateHistoryEntry(ctx context.Context, arg CreateHistoryEntryParams) (History, error) {
	row := q.db.QueryRowContext(ctx, createHistoryEntry,
		arg.CollectionID,
		arg.CollectionName,
		arg.EndpointName,
		arg.Method,
		arg.Url,
		arg.StatusCode,
		arg.Duration,
		arg.ResponseSize,
		arg.RequestHeaders,
		arg.QueryParams,
		arg.RequestBody,
		arg.ResponseBody,
		arg.ResponseHeaders,
		arg.ExecutedAt,
	)
	var i History
	err := row.Scan(
		&i.ID,
		&i.CollectionID,
		&i.CollectionName,
		&i.EndpointName,
		&i.Method,
		&i.Url,
		&i.StatusCode,
		&i.Duration,
		&i.ResponseSize,
		&i.RequestHeaders,
		&i.QueryParams,
		&i.RequestBody,
		&i.ResponseBody,
		&i.ResponseHeaders,
		&i.ExecutedAt,
	)
	return i, err
}

const deleteHistoryEntry = `-- name: DeleteHistoryEntry :exec
DELETE FROM history
WHERE id = ?
`

func (q *Queries) DeleteHistoryEntry(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteHistoryEntry, id)
	return err
}

const deleteOldHistory = `-- name: DeleteOldHistory :exec
DELETE FROM history
WHERE executed_at < datetime('now', '-30 days')
`

func (q *Queries) DeleteOldHistory(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteOldHistory)
	return err
}

const getHistoryByCollection = `-- name: GetHistoryByCollection :many
SELECT id, endpoint_name, status_code, executed_at, url, method FROM history
WHERE collection_id = ?
ORDER BY executed_at DESC
LIMIT ? OFFSET ?
`

type GetHistoryByCollectionParams struct {
	CollectionID sql.NullInt64 `db:"collection_id" json:"collection_id"`
	Limit        int64         `db:"limit" json:"limit"`
	Offset       int64         `db:"offset" json:"offset"`
}

type GetHistoryByCollectionRow struct {
	ID           int64          `db:"id" json:"id"`
	EndpointName sql.NullString `db:"endpoint_name" json:"endpoint_name"`
	StatusCode   int64          `db:"status_code" json:"status_code"`
	ExecutedAt   string         `db:"executed_at" json:"executed_at"`
	Url          string         `db:"url" json:"url"`
	Method       string         `db:"method" json:"method"`
}

func (q *Queries) GetHistoryByCollection(ctx context.Context, arg GetHistoryByCollectionParams) ([]GetHistoryByCollectionRow, error) {
	rows, err := q.db.QueryContext(ctx, getHistoryByCollection, arg.CollectionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetHistoryByCollectionRow
	for rows.Next() {
		var i GetHistoryByCollectionRow
		if err := rows.Scan(
			&i.ID,
			&i.EndpointName,
			&i.StatusCode,
			&i.ExecutedAt,
			&i.Url,
			&i.Method,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHistoryById = `-- name: GetHistoryById :one
SELECT id, collection_id, collection_name, endpoint_name, method, url, status_code, duration, response_size, request_headers, query_params, request_body, response_body, response_headers, executed_at FROM history
WHERE id = ?
`

func (q *Queries) GetHistoryById(ctx context.Context, id int64) (History, error) {
	row := q.db.QueryRowContext(ctx, getHistoryById, id)
	var i History
	err := row.Scan(
		&i.ID,
		&i.CollectionID,
		&i.CollectionName,
		&i.EndpointName,
		&i.Method,
		&i.Url,
		&i.StatusCode,
		&i.Duration,
		&i.ResponseSize,
		&i.RequestHeaders,
		&i.QueryParams,
		&i.RequestBody,
		&i.ResponseBody,
		&i.ResponseHeaders,
		&i.ExecutedAt,
	)
	return i, err
}
